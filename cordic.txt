=== The new CORDIC ===

== El puto step counter ==

Me gustaría optimizar el step counter ... de forma que tuviese el ancho óptimo (en función del número de bits de precisión del pipeline) y que dependiese de dicho jodido generic. El problema es que dependemos en gran medida de lo que el ISE sintetice (ya no nos metemos a cómo se comportarían otros sintetizadores que haya por ahí). La verdad, es q por mi experiencia me atrevería a afirmar que el sintetizador de la versión del ISE que estoy usando (la 7.1) no tiene que ser ninguna virguería, así que supongo que algo que sintetiza correctamente aquí debería sintetizar de puta madre en cualquier otro sitio. Lo cierto es que eso es algo que habría que comprobar en un futuro.

Comienza el proceso de "búsqueda y captura" del código que me permita en ISE generar un step_counter del ancho óptimo dado el generic de prec

= (26 de julio) Test 1: =

Ufff... no me acuerdo, pero ya estuve haciendo algo hoy por la mañana en casa, antes de ir al chollo, y no funcionó del todo.
Esencialmente, en lugar del log2 del siguiente test, estaba usando un log, dándole 2.0 como base, y no sintetizaba bien: infería un contador de 2 bits (!?!?), en lugar de uno de 4 bits, como sería necesario.

= (26 de julio) Test 2: cambiamos log por log2 =
Descubrí que math_real incluía un log2. Lo sustituí y volví a sintetizar. El resultado? Como si no hubiese limitacióin en el std_logic_vector, ya que infiere un contador de 16 bits.

El código:
<code>
        -- Counter process. For the internal process counter.
        -- # of steps = PREC BITS! See description for more info
	step_counter : process(clk)
                -- I don't want to force a range, as I don't want the
                -- synthesizer to infere the logic to correctly saturate and
                -- return to 0.
		variable step_counter : std_logic_vector((integer(round(2.0 ** ceil(log2(real(prec - 1))))) - 1) downto 0);
	begin
		if (rising_edge(clk)) then
			if (init = '1') then
				step_counter := (others => '0');
			else
                                -- To achieve an OPTIMAL counter size, make it
                                -- fold the CORRECT WAY (on saturation of
                                -- optimun width)
                                if (unsigned(step_counter) = (integer(round(2.0 ** ceil(log2(real(prec - 1))))) - 1)) then
                                        step_counter := (others => '0');
                                else
                                        step_counter := std_logic_vector(unsigned(step_counter) + 1);
                                end if;
			end if;
		end if;
		step <= to_integer(unsigned(step_counter));
</code>

El SYR (synthesis report):
<code>
    Found 16-bit up counter for signal <step_counter3>.
</code>

Sorprende en el SYR lo de 16 bit para el step_counter 
