--------------------------------------------------------------------------------
-- *** Brief desc ***
--
-- Class: sequential iterative
--
-- A PLL phase loop. Follows run_done interface.
--
-- *** Description ***
--
-- Has: synchronous reset.
--
-- ** PORT DESCRIPTION **
--
-- rst -> Synchronous reset port. A reset ONLY initializes some seq elements to a initial known
-- state, but does not reset some big internal storage elements as buffers (see FA). It's stupid, as
-- the presence of a FA will always mean that a big initial # of samples are needed to obtain stable
-- output.
--
-- *** Changelog ***
--
-- Revision 0.04 - Added register in the middle of a big big big combinational path (pi_int ->
-- pi_adder -> freq2phase input adder -> freq_2_phase reg).  Added at 37 % of total delay path [not
-- the best place], in a "correct" place. pi -> REG -> freq2phase
--
-- Revision 0.03 - Super change. Now, makes use of new seq. block control iface
--
-- Revision 0.02 - Interface modification. Good phase_det cycle integration with rest of pipeline.
--
-- Revision 0.01 - File Created
-- 
--------------------------------------------------------------------------------
#include "configuration.inc"

library IEEE;
library WORK;
use WORK.COMMON.all;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;


entity phase_loop is
     port (
          clk, rst, run : in std_logic;
          norm_input : in std_logic_vector(PIPELINE_WIDTH - 1 downto 0);
          phase, norm_sin : out std_logic_vector(PIPELINE_WIDTH - 1 downto 0);
          -- freq : out std_logic_vector(PIPELINE_WIDTH - 1 downto 0); I CANNOT SHOW FREQ!!!! 50 => 6 bits magnitude!!!!!!
          done : out std_logic);
end phase_loop;


architecture alg of phase_loop is
     -- Types
     type state_t is (ST_DONE, ST_RUNNING, ST_LAST);

     -- === Gain constants ===
     -- Ganancias originales del PI:
     --  * Kp = 100
     --  * Ki = 1000
     -- El Ki se podía usar directamente, ya que es una constante acoplada en un integrador.
     -- Kp, tal y como está, es inutilizable, ya que satura el pipeline de magnitud reducida.
     -- La solución está en distribuir la ganancia del Kp al "integrador" del NCO (entidad freq2phase).
     -- Así, haremos:
     --  * G = 25
     --  * Kp' = Kp / G = 4
     --  * Ki' = ki / G = 40
     -- La ganancia G se integra en el NCO
     constant PHASE_LOOP_PI_I_CONST : real := 40.0;
     constant PHASE_LOOP_PI_P_CONST : real := 4.0;
     constant PHASE_LOOP_G : real := 25.0;
     
     -- Internal signals
     signal phase_s, phase_det_out_s, fa_out_s : std_logic_vector(PIPELINE_WIDTH - 1 downto 0);
     signal phase_det_done_s, phase_det_done_pulsed_s, fva_done_s, pi_done_s, pi_done_REG_s : std_logic;
     signal phase_det_run_s : std_logic;
     signal fva_delayed_done_s, pi_delayed_done_s, pi_delayed_done_REG_s, freq2phase_delayed_done_s : std_logic;
     -- > PI signals
     signal p_kcm_out_s, pi_int_out_s, pi_adder_out_s, pi_adder_out_REG_s : std_logic_vector(PIPELINE_WIDTH - 1 downto 0);
     -- GARBAGE SIGNALS
     -- These are here because ModelSim complains about keeping a formal
     -- partially open (some of its bits are asigned, other are opened), and
     -- ModelSim requires, at the same time, all of the formal bits to be
     -- mapped to a signal. The only way is to use garbage signals, that
     -- later during synthesis get deleted by the synthesizer.
     signal garbage_1_s, garbage_2_s, garbage_3_s : std_logic;
begin
     -- ** Big blocks **
     phase_det_i : entity work.phase_det(alg)
          port map (
               run => phase_det_run_s,
               rst => rst, clk => clk,
               norm_input => norm_input,
               curr_phase => phase_s,
               -- Out value signals
               phase_error => phase_det_out_s,
               norm_output => norm_sin,
               -- Out control signals
               done => phase_det_done_s);

     phase_det_done_pulser : entity work.done_pulser(beh)
          port map (
               clk => clk, en  => '1', rst => rst,
               i   => phase_det_done_s,
               o   => phase_det_done_pulsed_s);
     
     fa_i : entity work.fa(beh)
          generic map (
               width => PIPELINE_WIDTH,
               prec  => PIPELINE_PREC,
               -- k => AC_FREQ,
               delay => 100,     -- fs / 100 Hz = 10000 / 100 = 100
               delayer_width => 2)
          port map (
               clk => clk, rst => rst,
               i => phase_det_out_s,
               o => fa_out_s,
               run_en => phase_det_done_pulsed_s,
               run_passthru => fva_done_s,
               delayer_in(0) => '-',
               delayer_in(1) => phase_det_done_s,
               delayer_out(0) => garbage_1_s,
               delayer_out(1) => fva_delayed_done_s);

     -- PI filter components
     pi_p_kcm : entity work.kcm(CONF_KCM_ARCHITECTURE_STR)
          generic map (
               k => PHASE_LOOP_PI_P_CONST)
          port map (
               i => fa_out_s,
               o => p_kcm_out_s);

     pi_int : entity work.kcm_integrator(beh)
          generic map (
               k => PHASE_LOOP_PI_I_CONST,
               delayer_width => 2)
          port map (
               clk => clk, rst => rst,
               run_en => fva_done_s,
               i => fa_out_s,
               o => pi_int_out_s,
               run_passthru => pi_done_s,
               delayer_in(0) => '-',
               delayer_in(1) => fva_delayed_done_s,
               delayer_out(0) => garbage_2_s,  -- open <- modelsim
                                               -- doesn't like this
               delayer_out(1) => pi_delayed_done_s);

     pi_adder : entity work.adder(alg)
          port map (
               a => pi_int_out_s,
               b => p_kcm_out_s,
               o => pi_adder_out_s,
               f_ov => open,
               f_z => open);

     -- Speed up register. Combinational path formed by pi_int -> pi_adder
     -- -> freq2phase combinational logic at input is TOO long
     pi_out_reg_i : entity work.reg(alg)
          generic map (
               width => PIPELINE_WIDTH + 2)
          port map (
               clk => clk,
               we  => '1',
               rst => rst,
               i(PIPELINE_WIDTH - 1 downto 0) => pi_adder_out_s,
               i(PIPELINE_WIDTH) => pi_done_s,
               i(PIPELINE_WIDTH + 1) => pi_delayed_done_s,
               o(PIPELINE_WIDTH - 1 downto 0) => pi_adder_out_REG_s,
               o(PIPELINE_WIDTH) => pi_done_REG_s,
               o(PIPELINE_WIDTH + 1) => pi_delayed_done_REG_s);
     
     freq2phase_i : entity work.freq2phase(beh)
          generic map (
               width => PIPELINE_WIDTH,
               delayer_width => 2,
               gain => PHASE_LOOP_G)
          port map (
               clk => clk, rst => rst,
               f => pi_adder_out_REG_s,
               p => phase_s,
               run_en => pi_done_REG_s,
               run_passthru => open,
               delayer_in(0) => '-',
               delayer_in(1) => pi_delayed_done_REG_s,
               delayer_out(0) => garbage_3_s,
               delayer_out(1) => freq2phase_delayed_done_s);

     phase <= phase_s;
     done <= freq2phase_delayed_done_s and phase_det_done_s;
     phase_det_run_s <= run and freq2phase_delayed_done_s and phase_det_done_s;
end alg;
